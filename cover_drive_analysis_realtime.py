# -*- coding: utf-8 -*-
"""cover_drive_analysis_realtime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oz8gG-qlp21O_0nYS6MtTfqHTmEbcHsP
"""

!pip install mediapipe opencv-python numpy pytube matplotlib

!pip install yt-dlp

import cv2
import mediapipe as mp
import numpy as np
import os
import json
import time
import matplotlib.pyplot as plt
from pytube import YouTube
import yt-dlp

def download_video(url, output_filename='input.mp4'):
    if os.path.exists(output_filename):
        print("Video already downloaded.")
        return
    ydl_opts = {
        'outtmpl': output_filename,  # Save as input.mp4
        'format': 'best',  # Best quality
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])
    print("Video downloaded successfully.")

def calculate_angle(a, b, c):
    ba = a - b
    bc = c - b
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
    return np.degrees(angle)

def get_landmark_point(landmark):
    return np.array([landmark.x, landmark.y])

def analyze_video(video_path):
    mp_pose = mp.solutions.pose
    mp_drawing = mp.solutions.drawing_utils
    pose = mp_pose.Pose(model_complexity=0, min_detection_confidence=0.5, min_tracking_confidence=0.5)

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        raise ValueError("Unable to open video file.")

    fps = cap.get(cv2.CAP_PROP_FPS)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    num_frames = 0
    start_time = time.time()

    os.makedirs('output', exist_ok=True)
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter('output/annotated_video.mp4', fourcc, fps, (width, height))

    elbows = []
    leans = []
    head_dists = []
    foot_angles = []
    frame_times = []

    resized_w = 640
    resized_h = int(640 * height / width) if width > 0 else 480

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        num_frames += 1
        current_time = (num_frames - 1) / fps
        frame_times.append(current_time)

        image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        small_frame = cv2.resize(image_rgb, (resized_w, resized_h))
        results = pose.process(small_frame)

        if results.pose_landmarks:
            for lm in results.pose_landmarks.landmark:
                lm.x = lm.x * width / resized_w
                lm.y = lm.y * height / resized_h

            mp_drawing.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

            landmarks = results.pose_landmarks.landmark
            try:
                # Front elbow angle (left for right-handed batter)
                left_shoulder = get_landmark_point(landmarks[11])
                left_elbow = get_landmark_point(landmarks[13])
                left_wrist = get_landmark_point(landmarks[15])
                elbow_angle = calculate_angle(left_shoulder, left_elbow, left_wrist)
                elbows.append(elbow_angle)

                # Spine lean
                mid_shoulder = (get_landmark_point(landmarks[11]) + get_landmark_point(landmarks[12])) / 2
                mid_hip = (get_landmark_point(landmarks[23]) + get_landmark_point(landmarks[24])) / 2
                spine_vector = mid_shoulder - mid_hip
                vertical_vector = np.array([0, -1])
                spine_lean = np.degrees(np.arccos(np.clip(np.dot(spine_vector / np.linalg.norm(spine_vector), vertical_vector), -1.0, 1.0)))
                leans.append(spine_lean)

                # Head-over-knee distance
                head = get_landmark_point(landmarks[0])
                front_knee = get_landmark_point(landmarks[25])
                head_dist = np.abs(head[0] - front_knee[0])
                head_dists.append(head_dist)

                # Front foot direction
                left_heel = get_landmark_point(landmarks[29])
                left_toe = get_landmark_point(landmarks[31])
                foot_vector = left_toe - left_heel
                foot_angle = np.degrees(np.arctan2(foot_vector[1], foot_vector[0]))
                foot_angles.append(foot_angle)

                # Overlays
                cv2.putText(frame, f"Elbow: {elbow_angle:.0f}deg", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                cv2.putText(frame, f"Spine Lean: {spine_lean:.0f}deg", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                cv2.putText(frame, f"Head Dist: {head_dist:.2f}", (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                cv2.putText(frame, f"Foot Dir: {foot_angle:.0f}deg", (10, 120), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

                # Feedback cues
                y_pos = 150
                if elbow_angle > 140:
                    cv2.putText(frame, u"\u2705 Good elbow elevation", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                else:
                    cv2.putText(frame, u"\u274C Raise front elbow higher", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                y_pos += 30
                if spine_lean < 15:
                    cv2.putText(frame, u"\u2705 Good balance", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                else:
                    cv2.putText(frame, u"\u274C Reduce spine lean", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                y_pos += 30
                if head_dist < 0.1:
                    cv2.putText(frame, u"\u2705 Head over knee", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                else:
                    cv2.putText(frame, u"\u274C Head not over front knee", (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)

            except:
                pass  # Handle missing landmarks gracefully

        out.write(frame)

    cap.release()
    out.release()

    avg_fps = num_frames / (time.time() - start_time)
    print(f"Average FPS: {avg_fps:.2f}")

    # Compute summaries if data available
    evaluation = {}
    if len(elbows) > 0:
        avg_elbow = np.mean(elbows)
        avg_lean = np.mean(leans)
        avg_head_dist = np.mean(head_dists)
        avg_foot_angle = np.mean(foot_angles)

        # Scores and feedback
        if avg_elbow > 160:
            swing_score = 9
            swing_feedback = "Excellent elbow elevation for swing control."
        elif avg_elbow > 140:
            swing_score = 7
            swing_feedback = "Good elbow position, but aim higher for better control."
        else:
            swing_score = 5
            swing_feedback = "Improve front elbow lift to enhance swing control."

        if avg_lean < 10:
            balance_score = 9
            balance_feedback = "Excellent balance with minimal spine lean."
        elif avg_lean < 20:
            balance_score = 7
            balance_feedback = "Moderate balance; reduce lean for stability."
        else:
            balance_score = 5
            balance_feedback = "Excessive spine lean affecting balance."

        if avg_head_dist < 0.05:
            head_score = 9
            head_feedback = "Perfect head alignment over the front knee."
        elif avg_head_dist < 0.1:
            head_score = 7
            head_feedback = "Good head position; refine for optimal alignment."
        else:
            head_score = 5
            head_feedback = "Head not sufficiently over front knee; adjust stance."

        if 0 < avg_foot_angle < 45:
            footwork_score = 8
            footwork_feedback = "Appropriate front foot direction for the shot."
        else:
            footwork_score = 6
            footwork_feedback = "Adjust front foot pointing for better footwork."

        # Follow-through: simplistic, use last 20% for elbow
        follow_through_score = swing_score  # Placeholder
        follow_through_feedback = "Solid follow-through based on swing metrics."

        evaluation = {
            "Footwork": {"score": footwork_score, "feedback": footwork_feedback},
            "Head Position": {"score": head_score, "feedback": head_feedback},
            "Swing Control": {"score": swing_score, "feedback": swing_feedback},
            "Balance": {"score": balance_score, "feedback": balance_feedback},
            "Follow-through": {"score": follow_through_score, "feedback": follow_through_feedback}
        }

        # Skill grade
        avg_score = np.mean([footwork_score, head_score, swing_score, balance_score, follow_through_score])
        if avg_score > 8:
            skill_grade = "Advanced"
        elif avg_score > 6:
            skill_grade = "Intermediate"
        else:
            skill_grade = "Beginner"
        evaluation["Skill Grade"] = skill_grade

        # Smoothness
        var_elbow = np.var(elbows)
        evaluation["Smoothness"] = {"elbow_variance": float(var_elbow), "comment": "Lower variance indicates smoother motion."}

        # Plot
        plt.figure()
        plt.plot(frame_times[:len(elbows)], elbows)
        plt.xlabel('Time (s)')
        plt.ylabel('Elbow Angle (deg)')
        plt.title('Elbow Angle over Time')
        plt.savefig('output/elbow_angle_plot.png')
        plt.close()

    with open('output/evaluation.json', 'w') as f:
        json.dump(evaluation, f, indent=4)

    pose.close()
    return evaluation

if __name__ == "__main__":
    video_url = "https://youtube.com/shorts/vSX3IRxGnNY"
    download_video(video_url)
    analyze_video('input.mp4')